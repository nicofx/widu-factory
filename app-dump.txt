// apps/api-core/src/app.module.ts

import { Module } from '@nestjs/common';
import { ConfigModule } from '@nestjs/config';

import { MongooseModule } from '@nestjs/mongoose';
import { PassportModule } from '@nestjs/passport';

import { UsersModule } from './modules/users/users.module';

import { TenantMiddleware } from './common/middlewares/tenant.middleware';

import { PipelineFactoryModule } from './pipeline/factory/pipeline-factory.module';
import { RuntimePipelineModule } from './pipeline/runtime-pipeline.module';
import { PipelineInterceptor } from './pipeline/interceptors/pipeline.interceptor';
import { TestingModule } from './testing/testing.module';
import { APP_INTERCEPTOR } from '@nestjs/core';

@Module({
  imports: [
    // ‚Äî Configuraci√≥n global de variables de entorno ‚Äî
    ConfigModule.forRoot({
      envFilePath: '/app/.env',
      isGlobal: true,
    }),

    // ‚Äî Conexi√≥n a MongoDB ‚Äî
    MongooseModule.forRootAsync({
      useFactory: () => ({
        uri: process.env.MONGO_URI,
      }),
    }),

    // ‚Äî M√≥dulos ‚Äúlegacy‚Äù que ya exist√≠an ‚Äî
    PassportModule,
    UsersModule,

    // ‚Äî A√ëADIMOS aqu√≠ los m√≥dulos de Pipeline ‚Äî
    PipelineFactoryModule,
    RuntimePipelineModule,

    // ‚Äî Resto de m√≥dulos que siguen intactos ‚Äî
    TestingModule,
  ],
  controllers: [
    // (Si tuvieras controladores globales que quisieras declarar, ir√≠an aqu√≠)
  ],
  providers: [
    // ‚Äî Middlewares, estrategias y servicios que ya ten√≠as ‚Äî
    TenantMiddleware,

    // ‚Äî Registramos el PipelineInterceptor como provider ‚Äî
    {
      provide: APP_INTERCEPTOR,
      useClass: PipelineInterceptor,
    },
  ],
  // No exportamos nada del Pipeline desde AppModule, 
  // ya que los m√≥dulos de Pipeline se importan directamente arriba.
})
export class AppModule {}
import { Injectable, NestMiddleware } from '@nestjs/common';
import { Response, NextFunction } from 'express';
import { Request as ExpressRequest } from 'express';

interface AuthenticatedRequest extends ExpressRequest {
  user?: {
    sub: string;
    email: string;
    role: string;
    tenant: string;
    [key: string]: any;
  };
  tenant?: string;
}

@Injectable()
export class TenantMiddleware implements NestMiddleware {
  use(req: AuthenticatedRequest, res: Response, next: NextFunction) {
    if (req.user?.tenant) {
      req.tenant = req.user.tenant;
    } else {
      req.tenant = 'default';
    }
    next();
  }
}
// apps/api-core/src/main.ts

import * as dotenv from 'dotenv';
import * as path from 'path';
dotenv.config({ path: path.join(__dirname, '..', '..', '.env') });

import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';
import { AppModule } from './app.module';
import { NestFactory } from '@nestjs/core';
import { TenantMiddleware } from './common/middlewares/tenant.middleware';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);


  // Middleware global para tenant
  app.use(new TenantMiddleware().use);

  // Swagger / OpenAPI
  const config = new DocumentBuilder()
    .setTitle('WiduFactory API')
    .setDescription('Documentaci√≥n de endpoints')
    .setVersion('1.0')
    .addApiKey(
      {
        type: 'apiKey',
        name: 'x-tenant',
        in: 'header',
      },
      'x-tenant',
    )
    .addBearerAuth(
      {
        type: 'http',
        scheme: 'bearer',
        bearerFormat: 'JWT',
        in: 'header',
      },
      'access-token',
    )
    .build();

  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('docs', app, document);

  await app.listen(3000);
  
  console.log('üöÄ API corriendo en http://0.0.0.0:3000');
}

bootstrap();
import { Prop, Schema, SchemaFactory } from '@nestjs/mongoose';
import { Document, Types } from 'mongoose';

@Schema()
export class User {
  @Prop({ required: true, unique: true })
  email!: string;
  
  @Prop({ required: true })
  password!: string;
  
  @Prop({ required: true })
  role!: string;
  
  @Prop({ required: true })
  tenant!: string;
  
  @Prop({ default: 'default' }) // üëà ya preparado para que sea opcional
  plan?: string;
  
  @Prop({ default: 'jwt' }) // üëà agregamos esta l√≠nea
  strategy?: string;
  
  @Prop({ default: false })
  confirmed!: boolean;
}

export type UserDocument = Document<unknown, {}, User> & User & { _id: Types.ObjectId };

export const UserSchema = SchemaFactory.createForClass(User);
import { Module } from '@nestjs/common';
import { MongooseModule } from '@nestjs/mongoose';
import { User, UserSchema } from './schemas/user.schema';
import { UsersService } from './users.service';

@Module({
  imports: [
    MongooseModule.forFeature([
      { name: User.name, schema: UserSchema },
    ]),
  ],
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}
import { Injectable } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model } from 'mongoose';
import { User, UserDocument } from './schemas/user.schema';

@Injectable()
export class UsersService {
  constructor(
    @InjectModel(User.name)
    private readonly userModel: Model<UserDocument>
  ) {}

  async findByEmail(email: string): Promise<UserDocument | null> {
    return this.userModel.findOne({ email });
  }

  async create(data: Partial<UserDocument>): Promise<UserDocument> {
    return new this.userModel(data).save();
  }

  async findById(id: string): Promise<UserDocument | null> {
    console.log('[USER SERVICE] Buscando usuario con ID:', id);
    return this.userModel.findById(id).exec(); // üëà importante
  }

  async updatePassword(id: string, password: string) {
    return this.userModel.findByIdAndUpdate(id, { password });
  }
}

// src/pipeline/decorators/pipeline.decorator.ts
import { SetMetadata } from '@nestjs/common';

export const USE_PIPELINE_KEY = 'USE_PIPELINE';
export const SKIP_PIPELINE_KEY = 'SKIP_PIPELINE';

/**
 * @UsePipeline('NombrePipeline')
 */
export const UsePipeline = (name: string) =>
  SetMetadata(USE_PIPELINE_KEY, name);

/**
 * @SkipPipeline()
 */
export const SkipPipeline = () =>
  SetMetadata(SKIP_PIPELINE_KEY, true);
// src/pipeline/decorators/step-definition.decorator.ts
import { SetMetadata } from '@nestjs/common';
import { PipelinePhase } from '../interfaces/pipeline-step.interface';

export interface StepMetadata {
  name: string;
  phase: PipelinePhase;
  injects?: string[]; // nombres de subsistemas que el step necesita
}

export const STEP_METADATA_KEY = 'STEP_METADATA';

export function StepDefinition(meta: StepMetadata): ClassDecorator {
  return SetMetadata(STEP_METADATA_KEY, meta);
}

export function getStepMetadata(target: any): StepMetadata | undefined {
  return Reflect.getMetadata(STEP_METADATA_KEY, target);
}
// src/pipeline/factory/configurable-pipeline.factory.ts
import { Injectable, Logger } from '@nestjs/common';
import { PipelineFactory } from './pipeline-factory.interface';
import { PipelinePhase, PipelineStep } from '../interfaces/pipeline-step.interface';
import { ConfigurationSubsystem } from '../subsystems/configuration/configuration.subsystem';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { STEP_REGISTRY } from '../steps/step-registry';
import { RequestContext } from '../interfaces/context.interface';

@Injectable()
export class ConfigurablePipelineFactory implements PipelineFactory {
  private readonly logger = new Logger(ConfigurablePipelineFactory.name);

  constructor(
    private readonly configService: ConfigurationSubsystem,
    private readonly contextService: ContextSubsystem,
  ) {}

  /**
   * Construye y retorna el pipeline seg√∫n JSON de tenant (o default.json) basado en 'name'.
   */
  async getPipeline(
    name: string,
    context: RequestContext
  ): Promise<Record<PipelinePhase, PipelineStep[]>> {
    // 1) Obtener el config mergeado entre default + tenant
    const cfg = this.configService.getConfig(context);
    const pipelinesCfg: Record<string, any> = cfg.pipelines || {};

    // 2) Primero intento el pipeline espec√≠fico:
    let pipelineDef = pipelinesCfg[name];

    // 3) Si no existe, uso el pipeline ‚Äúdefault‚Äù del JSON:
    if (!pipelineDef) {
      pipelineDef = pipelinesCfg['default'];
      this.logger.warn(`Pipeline "${name}" no encontrado en config; usando "default".`);
    }

    // 4) Si a√∫n as√≠ no hay definici√≥n (ni ‚Äúname‚Äù ni ‚Äúdefault‚Äù), hago fallback m√≠nimo:
    if (!pipelineDef) {
      this.logger.error(`No hay pipeline "default" en JSON. Usando fallback m√≠nimo.`);
      return this.getDefaultPipeline(context);
    }

    // 5) Para cada fase, instanciar pasos seg√∫n el array de strings:
    const result: Record<PipelinePhase, PipelineStep[]> = {
      [PipelinePhase.PRE]: [],
      [PipelinePhase.PROCESSING]: [],
      [PipelinePhase.POST]: [],
    };

    // Helper para instanciar un step dado su nombre:
    const instantiateStep = (stepName: string): PipelineStep => {
      const StepClass = STEP_REGISTRY[stepName];
      if (!StepClass) {
        throw new Error(`Paso "${stepName}" no registrado en STEP_REGISTRY.`);
      }
      return new StepClass(this.contextService);
    };

    // 6) Recorrer las tres fases: ‚Äúpre‚Äù, ‚Äúprocessing‚Äù, ‚Äúpost‚Äù
    for (const phase of Object.values(PipelinePhase) as PipelinePhase[]) {
      const phaseKey = phase as keyof typeof pipelineDef;
      const stepNames: string[] = Array.isArray(pipelineDef[phaseKey])
        ? pipelineDef[phaseKey]
        : [];

      for (const stepName of stepNames) {
        result[phase].push(instantiateStep(stepName));
      }
    }

    return result;
  }

  /**
   * Fallback m√≠nimo si ni "name" ni "default" aparecen en JSON:
   * LoggingStep en PRE, vac√≠os en PROCESSING, ResponseFormatter en POST.
   */
  async getDefaultPipeline(
    context: RequestContext
  ): Promise<Record<PipelinePhase, PipelineStep[]>> {
    const result: Record<PipelinePhase, PipelineStep[]> = {
      [PipelinePhase.PRE]: [],
      [PipelinePhase.PROCESSING]: [],
      [PipelinePhase.POST]: [],
    };
    // Intento instanciar LoggingStep y ResponseFormatterStep si est√°n registrados
    if (STEP_REGISTRY['LoggingStep']) {
      result[PipelinePhase.PRE].push(new STEP_REGISTRY['LoggingStep'](this.contextService));
    }
    if (STEP_REGISTRY['ResponseFormatterStep']) {
      result[PipelinePhase.POST].push(new STEP_REGISTRY['ResponseFormatterStep'](this.contextService));
    }
    return result;
  }
}
// src/core/pipeline/registry/hardcoded-pipeline.factory.ts
import { Injectable } from '@nestjs/common';
import { PipelineFactory } from './pipeline-factory.interface';
import { PipelinePhase, PipelineStep } from '../../pipeline/interfaces/pipeline-step.interface';

// Pasos ‚Äúcore‚Äù que ya ten√≠as:
import { LoggingStep } from '../../pipeline/steps/logging-step';
import { NoOpStep } from '../../pipeline/steps/noop-step';
import { ResponseFormatterStep } from '../../pipeline/steps/response-formatter-step';

// Nuevos pasos gen√©ricos ‚Äúcalidad‚Äù:
import { HeaderCheckStep } from '../../pipeline/steps/header-check.step';
import { RateLimiterStep } from '../../pipeline/steps/rate-limiter.step';
import { TokenParserStep } from '../../pipeline/steps/token-parser.step';
import { NormalizerStep } from '../../pipeline/steps/normalizer.step';
import { ContextBuilderStep } from '../../pipeline/steps/context-builder.step';
import { BusinessAuditStep } from '../../pipeline/steps/business-audit.step';
import { MetadataTaggerStep } from '../../pipeline/steps/metadata-tagger.step';
import { NotifierStep } from '../../pipeline/steps/notifier.step';
import { TracerStep } from '../../pipeline/steps/tracer.step';

import { ContextSubsystem } from '../../pipeline/subsystems/context/context.subsystem';
import { ServiceResolverSubsystem } from '../../pipeline/subsystems/service/service-resolver.subsystem';
import { ValidationStep } from '../steps/validation.step';

@Injectable()
export class HardcodedPipelineFactory implements PipelineFactory {
  constructor(
    private readonly contextService: ContextSubsystem,
    private readonly serviceResolver: ServiceResolverSubsystem,
  ) {}

  /**
   * Todos los pasos reciben (por convenio) solo ContextSubsystem en el constructor.
   */
  private instantiate(stepClass: new (...args: any[]) => PipelineStep): PipelineStep {
    return new stepClass(this.contextService);
  }

  async getPipeline(name: string): Promise<Record<PipelinePhase, PipelineStep[]>> {
    switch (name) {
      case 'PipelineGen√©ricoDemo':
        return {
          [PipelinePhase.PRE]: [
            // 3 pasos PRE con l√≥gica real:
            this.instantiate(HeaderCheckStep),
            this.instantiate(RateLimiterStep),
            this.instantiate(TokenParserStep),
          ],
          [PipelinePhase.PROCESSING]: [
            // 4 pasos PROCESSING con l√≥gica real:
            this.instantiate(ValidationStep),
            this.instantiate(NormalizerStep),
            this.instantiate(ContextBuilderStep),
            this.instantiate(BusinessAuditStep),
          ],
          [PipelinePhase.POST]: [
            // 4 pasos POST con l√≥gica real + ResponseFormatter al final
            this.instantiate(MetadataTaggerStep),
            this.instantiate(NotifierStep),
            this.instantiate(TracerStep),
            this.instantiate(ResponseFormatterStep),
          ],
        };
      case 'TestPlanAccessPipeline':
        return {
          [PipelinePhase.PRE]: [this.instantiate(LoggingStep)],
          [PipelinePhase.PROCESSING]: [],
          [PipelinePhase.POST]: [],
        };
      case 'NoOpPipeline':
        return {
          [PipelinePhase.PRE]: [this.instantiate(LoggingStep)],
          [PipelinePhase.PROCESSING]: [this.instantiate(NoOpStep)],
          [PipelinePhase.POST]: [],
        };
      default:
        return this.getDefaultPipeline();
    }
  }

  async getDefaultPipeline(): Promise<Record<PipelinePhase, PipelineStep[]>> {
    return {
      [PipelinePhase.PRE]: [this.instantiate(LoggingStep)],
      [PipelinePhase.PROCESSING]: [],
      [PipelinePhase.POST]: [this.instantiate(ResponseFormatterStep)],
    };
  }
}
// src/pipeline/factory/pipeline-factory.interface.ts
import { PipelinePhase, PipelineStep } from '../interfaces/pipeline-step.interface';
import { RequestContext } from '../interfaces/context.interface';

export interface PipelineFactory {
  /**
   * Devuelve un mapa { pre: PipelineStep[], processing: PipelineStep[], post: PipelineStep[] }
   * EST√ÅNDAR: recibe el nombre del pipeline y el context, para que lea config por tenant.
   */
  getPipeline(
    name: string,
    context: RequestContext
  ): Promise<Record<PipelinePhase, PipelineStep[]>>;

  /**
   * Pipeline fallback m√≠nimo si nada m√°s aplica.
   */
  getDefaultPipeline(
    context: RequestContext
  ): Promise<Record<PipelinePhase, PipelineStep[]>>;
}
// src/pipeline/factory/pipeline-factory.module.ts
import { Module } from '@nestjs/common';
import { ConfigurablePipelineFactory } from './configurable-pipeline.factory';
import { RuntimePipelineModule } from '../runtime-pipeline.module';

@Module({
  imports: [
    RuntimePipelineModule,
  ],
  providers: [
    {
      provide: 'PIPELINE_FACTORY',
      useClass: ConfigurablePipelineFactory,
    },
  ],
  exports: ['PIPELINE_FACTORY'],
})
export class PipelineFactoryModule {}
// src/pipeline/interceptors/pipeline.interceptor.ts
import {
  CallHandler,
  ExecutionContext,
  Injectable,
  NestInterceptor,
  Inject,
} from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { Observable, from, switchMap } from 'rxjs';
import { USE_PIPELINE_KEY, SKIP_PIPELINE_KEY } from '../decorators/pipeline.decorator';
import { PipelineFactory } from '../factory/pipeline-factory.interface';
import { PipelineEngineService } from '../pipeline-engine.service';
import { RequestContext } from '../interfaces/context.interface';

@Injectable()
export class PipelineInterceptor implements NestInterceptor {
  constructor(
    private readonly reflector: Reflector,
    @Inject('PIPELINE_FACTORY') private readonly pipelineFactory: PipelineFactory,
    private readonly engine: PipelineEngineService,
  ) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const handler = context.getHandler();
    const skip = this.reflector.get<boolean>(SKIP_PIPELINE_KEY, handler);
    if (skip) {
      return next.handle();
    }

    const pipelineName =
      this.reflector.get<string>(USE_PIPELINE_KEY, handler) || 'default';

    const http = context.switchToHttp();
    const request = http.getRequest();
    const requestId = `REQ-${Date.now()}`;

    // Construir RequestContext nuevo:
    const requestContext: RequestContext = {
      requestId,
      body: request.body,
      headers: request.headers,
      user: request.user,
      meta: { logs: [] },
      services: {},
    };

    // Observable que ejecuta el pipeline seg√∫n tenant y lo inyecta antes del controller:
    const pipeline$ = from(
      this.pipelineFactory
        .getPipeline(pipelineName, requestContext)   // <-- le pasamos el context
        .then((steps) => this.engine.executeWithSteps(requestContext, steps))
        .then(() => {
          request.pipelineContext = requestContext;  // asignamos antes de seguir
        })
    );

    return pipeline$.pipe(
      switchMap(() => next.handle())
    );
  }
}
// src/pipeline/interfaces/context.interface.ts

export interface StepExecutionLog {
  phase: string;
  step: string;
  status: 'success' | 'error' | 'skipped';
  durationMs: number;
  details?: any;
}

export interface RequestContext {
  requestId: string;
  body: any;
  headers: Record<string, any>;
  user?: any;
  result?: any;
  errors?: any[];
  response?: any;
  // Cualquier dato extra que necesiten los Steps
  services?: Record<string, any>;
  // Metadatos internos: logs de steps, validaciones, permisos, etc.
  meta: {
    logs: StepExecutionLog[];
    [key: string]: any;
  };
}
// src/pipeline/interfaces/pipeline-step.interface.ts
export interface StepConfig {
  async?: boolean;
  parallelizable?: boolean;
  blocking?: boolean;
  critical?: boolean;
  onError?: 'continue' | 'stop' | 'skip' | 'retry';
}

export enum PipelinePhase {
  PRE = 'pre',
  PROCESSING = 'processing',
  POST = 'post',
}

export interface PipelineStep {
  execute(requestId: string): Promise<void>;
  config?: StepConfig;
}

// Para poder instanciar Steps din√°micamente
export interface PipelineStepConstructor {
  new (...args: any[]): PipelineStep;
}
// src/pipeline/engine/pipeline-engine.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { LogCollectorSubsystem } from './subsystems/log/log-collector.subsystem';
import { ContextSubsystem } from './subsystems/context/context.subsystem';
import { PipelinePhase, PipelineStep } from './interfaces/pipeline-step.interface';
import { AuditTrailSubsystem } from './subsystems/audit/audit-trail.subsystem';
import { ErrorManagerSubsystem } from './subsystems/error-manager/error-manager.subsystem';
import { StepFilterSubsystem } from './subsystems/filter/step-filter.subsystem';
import { RequestContext } from './interfaces/context.interface';
import { getStepMetadata } from './decorators/step-definition.decorator';


@Injectable()
export class PipelineEngineService {
  constructor(
    @Inject('REQUEST_PIPELINE')
    private readonly stepsByPhase: Record<PipelinePhase, PipelineStep[]>,
    private readonly audit: AuditTrailSubsystem,
    private readonly errorManager: ErrorManagerSubsystem,
    private readonly filter: StepFilterSubsystem,
    private readonly contextService: ContextSubsystem,
    private readonly logCollector: LogCollectorSubsystem,
  ) {}

  async executeWithSteps(
    context: RequestContext,
    stepsByPhase: Record<PipelinePhase, PipelineStep[]>,
  ): Promise<void> {
    // 1) almacenar el contexto para que los Steps puedan leerlo
    this.contextService.setContext(context);

    // 2) iterar por cada fase (pre, processing, post)
    for (const phase of Object.values(PipelinePhase)) {
      const phaseSteps = this.filter.filter(phase, stepsByPhase[phase] || [], context.requestId);
      if (phaseSteps.length === 0) {
        console.log(`[PipelineEngine] Fase "${phase}" sin steps habilitados`);
        continue;
      }

      for (const step of phaseSteps) {
        const start = Date.now();
        const meta = getStepMetadata(step.constructor);
        const stepName = meta?.name || 'UnknownStep';

        await this.audit.logEvent('StepStarted', { step: stepName, phase });
        try {
          await step.execute(context.requestId);
          const duration = Date.now() - start;
          await this.audit.logEvent('StepSucceeded', { step: stepName, phase, durationMs: duration });
          this.logCollector.collect(context, {
            phase,
            step: stepName,
            status: 'success',
            durationMs: duration,
          });
        } catch (err: any) {
          const duration = Date.now() - start;
          await this.errorManager.handle(err, context, stepName);
          await this.audit.logEvent('StepFailed', {
            step: stepName,
            phase,
            durationMs: duration,
            error: err.message,
          });
          this.logCollector.collect(context, {
            phase,
            step: stepName,
            status: 'error',
            durationMs: duration,
            details: err.message || err,
          });
          if (step.config?.onError !== 'continue') {
            this.contextService.deleteContext(context.requestId);
            throw err;
          }
        }
      }
    }

    // 3) al final eliminar el contexto
    this.contextService.deleteContext(context.requestId);
  }
}
// src/pipeline/request-pipeline.provider.ts
import { Provider } from '@nestjs/common';
import { PipelinePhase, PipelineStep, PipelineStepConstructor } from './interfaces/pipeline-step.interface';
import { getStepMetadata } from './decorators/step-definition.decorator';
import * as Steps from './steps';

// Verifica que sea un constructor con m√©todo .execute()
function isPipelineStepConstructor(obj: any): obj is PipelineStepConstructor {
  return typeof obj === 'function' && typeof obj.prototype?.execute === 'function';
}

export const RequestPipelineProvider: Provider = {
  provide: 'REQUEST_PIPELINE',
  useFactory: (
    context: any,
    logger: any,
    audit: any,
    error: any
  ): Record<PipelinePhase, PipelineStep[]> => {
    const steps: Record<PipelinePhase, PipelineStep[]> = {
      [PipelinePhase.PRE]: [],
      [PipelinePhase.PROCESSING]: [],
      [PipelinePhase.POST]: [],
    };

    const depsByName: { [key: string]: any } = {
      ContextSubsystem: context,
      LogCollectorSubsystem: logger,
      AuditTrailSubsystem: audit,
      ErrorManagerSubsystem: error,
    };

    for (const StepClass of Object.values(Steps)) {
      if (!isPipelineStepConstructor(StepClass)) continue;
      const meta = getStepMetadata(StepClass);
      if (!meta) continue;

      // Construir instanciando con los subsistemas que pide @StepDefinition.injects
      const constructorDeps = (meta.injects || []).map((name) => depsByName[name]);
      const instance = new (StepClass as PipelineStepConstructor)(...constructorDeps);
      steps[meta.phase].push(instance);
    }
    return steps;
  },
  inject: [
    require('./subsystems/context/context.subsystem').ContextSubsystem,
    require('./subsystems/log/log-collector.subsystem').LogCollectorSubsystem,
    require('./subsystems/audit/audit-trail.subsystem').AuditTrailSubsystem,
    require('./subsystems/error-manager/error-manager.subsystem').ErrorManagerSubsystem,
  ],
};
// src/pipeline/engine/runtime-pipeline.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { PipelineEngineService } from './pipeline-engine.service';
import { ContextSubsystem } from './subsystems/context/context.subsystem';
import { ServiceResolverSubsystem } from './subsystems/service/service-resolver.subsystem';
import { ConfigurationSubsystem } from './subsystems/configuration/configuration.subsystem';
import { ExecutionControllerSubsystem } from './subsystems/execution-controller/execution-controller.subsystem';
import { StepFilterSubsystem } from './subsystems/filter/step-filter.subsystem';
import { ErrorManagerSubsystem } from './subsystems/error-manager/error-manager.subsystem';
import { AuditTrailSubsystem } from './subsystems/audit/audit-trail.subsystem';
import { LogCollectorSubsystem } from './subsystems/log/log-collector.subsystem';
import { RequestPipelineProvider } from './request-pipeline.provider';
import { PipelineFactoryModule } from './factory/pipeline-factory.module';

@Module({
  imports: [
    forwardRef(() => PipelineFactoryModule),
  ],
  providers: [
    PipelineEngineService,
    RequestPipelineProvider,
    ContextSubsystem,
    LogCollectorSubsystem,
    AuditTrailSubsystem,
    ErrorManagerSubsystem,
    StepFilterSubsystem,
    ExecutionControllerSubsystem,
    ConfigurationSubsystem,        // <‚Äî aqu√≠
    ServiceResolverSubsystem,
  ],
  // Exportamos TODO lo que necesita cualquiera que importe este m√≥dulo:
  exports: [
    PipelineEngineService,
    ContextSubsystem,
    ServiceResolverSubsystem,
    ConfigurationSubsystem,        // <‚Äî a√±adir este
  ],
})
export class RuntimePipelineModule {}
// src/pipeline/steps/base-step.ts
import { PipelineStep, PipelinePhase, StepConfig } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { StepExecutionLog } from '../interfaces/context.interface';

@StepDefinition({
  name: 'BaseGenericStep',
  phase: PipelinePhase.PRE, // este valor es irrelevante en la pr√°ctica; cada subclase lo overridea
  injects: ['ContextSubsystem'],
})
export abstract class BaseGenericStep implements PipelineStep {
  config: StepConfig = { onError: 'continue' };

  protected readonly ctx: ContextSubsystem;

  constructor(ctx: ContextSubsystem) {
    this.ctx = ctx;
  }

  /** Nombre textual del paso. Cada subclase sobreescribe. */
  abstract getName(): string;

  /** Fase a la que pertenece: PRE | PROCESSING | POST. */
  abstract getPhase(): PipelinePhase;

  public async execute(requestId: string): Promise<void> {
    // 1) Tomar el RequestContext
    const context = this.ctx.getContext(requestId);
    if (!context) {
      // Si no existe contexto, simplemente retornamos (no podemos avanzar).
      throw new Error(`[${this.getName()}] Contexto no encontrado para requestId=${requestId}`);
    }

    // 2) Iniciar medici√≥n de tiempo
    const start = Date.now();

    // 3) Placeholder: aqu√≠ cada subclase puede ejecutar L√ìGICA real o extender.
    //    En esta implementaci√≥n base no hay l√≥gica de negocio: queda para la subclase.
    //    Ejemplo: await this.doWork(requestId);

    // 4) Calcular duraci√≥n
    const duration = Date.now() - start;

    // 5) Push al log de ejecuci√≥n
    const logEntry: StepExecutionLog = {
      phase: this.getPhase(),
      step: this.getName(),
      status: 'success',
      durationMs: duration,
    };
    context.meta.logs.push(logEntry);

    // 6) Imprimir en consola para debugging
    console.log(
      `[${this.getName()}] (${this.getPhase()}) requestId=${requestId} ‚Üí OK (${duration} ms)`
    );
  }
}
// src/pipeline/steps/business-audit.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

interface BusinessAuditEntry {
  action: string;
  step: string;
  time: number;
  payload: any;
}

@StepDefinition({
  name: 'BusinessAuditStep',
  phase: PipelinePhase.PROCESSING,
  injects: ['ContextSubsystem'],
})
export class BusinessAuditStep extends BaseGenericStep {
  // Si falla algo, continuamos (no es cr√≠tico)
  config = { onError: 'continue' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'BusinessAuditStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PROCESSING;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Crear lista si no existe
    if (!Array.isArray(context.meta.businessAudit)) {
      context.meta.businessAudit = [];
    }

    // 2) Construir entrada de auditor√≠a
    const entry: BusinessAuditEntry = {
      action: 'BusinessAudit',
      step: this.getName(),
      time: Date.now(),
      payload: context.meta.processedBody ?? null,
    };
    context.meta.businessAudit.push(entry);

    // 3) Tambi√©n podemos imprimir por consola
    console.log(`[BusinessAuditStep] Audit entry for requestId=${requestId}:`, entry);

    // 4) Log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/context-builder.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

@StepDefinition({
  name: 'ContextBuilderStep',
  phase: PipelinePhase.PROCESSING,
  injects: ['ContextSubsystem'],
})
export class ContextBuilderStep extends BaseGenericStep {
  // Continuamos aun si hay alg√∫n detalle (no cr√≠tico)
  config = { onError: 'continue' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'ContextBuilderStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PROCESSING;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Timestamp de recepci√≥n
    context.meta.requestReceivedAt = new Date().toISOString();
    // 2) Correlation ID = requestId
    context.meta.correlationId = requestId;
    // 3) Copiar ‚ÄúprocessedBody‚Äù para facilitar uso posterior
    context.meta.processedBody = context.meta.normalizedBody ?? context.meta.validatedBody ?? context.body;

    // 4) Log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/header-check.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

@StepDefinition({
  name: 'HeaderCheckStep',
  phase: PipelinePhase.PRE,
  injects: ['ContextSubsystem'],
})
export class HeaderCheckStep extends BaseGenericStep {
  // Queremos detener el pipeline si falla la validaci√≥n
  config = { onError: 'stop' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'HeaderCheckStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PRE;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Verificar que haya header "content-type" conteniendo "application/json"
    const contentType = context.headers['content-type'] as string | undefined;
    if (!contentType || !contentType.includes('application/json')) {
      throw new Error('[HeaderCheckStep] Falta header "content-type: application/json"');
    }

    // 2) Podemos chequear tambi√©n que venga un header "x-tenant" (opcional)
    const tenant = context.headers['x-tenant'];
    if (!tenant) {
      // Si no hay x-tenant, usamos ‚Äúdefault‚Äù, pero no lanzamos error.  
      context.meta.tenant = 'default';
    } else {
      context.meta.tenant = String(tenant);
    }

    // 3) Llamamos al base para registrar log de √©xito
    await super.execute(requestId);
  }
}
// apps/api-core/src/core/pipeline/steps/index.ts

export * from './business-audit.step';
export * from './context-builder.step';
export * from './header-check.step';
export * from './logging-step';
export * from './metadata-tagger.step';
export * from './noop-step';
export * from './normalizer.step';
export * from './notifier.step';
export * from './rate-limiter.step';
export * from './response-formatter-step';
export * from './token-parser.step';
export * from './tracer.step';
export * from './validation.step';
// ‚Ä¶y as√≠ con cada archivo de step que tengas‚Ä¶
// src/pipeline/steps/logging-step.ts
import { PipelineStep, PipelinePhase, StepConfig } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';

@StepDefinition({
  name: 'LoggingStep',
  phase: PipelinePhase.PRE,
  injects: ['ContextSubsystem'],
})
export class LoggingStep implements PipelineStep {
  config: StepConfig = { onError: 'continue' };
  constructor(private readonly contextService: ContextSubsystem) {}

  async execute(requestId: string): Promise<void> {
    const ctx = this.contextService.getContext(requestId);
    if (ctx) {
      console.log(`[LoggingStep] requestId=${requestId} ‚îÄ Body:`, ctx.body);
    } else {
      console.warn(`[LoggingStep] requestId=${requestId} ‚îÄ Context not found.`);
    }
  }
}
// src/pipeline/steps/metadata-tagger.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

@StepDefinition({
  name: 'MetadataTaggerStep',
  phase: PipelinePhase.POST,
  injects: ['ContextSubsystem'],
})
export class MetadataTaggerStep extends BaseGenericStep {
  // Si algo falla aqu√≠, continuamos (no es cr√≠tico)
  config = { onError: 'continue' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'MetadataTaggerStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.POST;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Agregar tags gen√©ricos a context.meta
    context.meta.responseTags = {
      version: '1.0',
      env: process.env.NODE_ENV ?? 'dev',
      taggedAt: new Date().toISOString(),
    };

    // 2) Log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/noop-step.ts
import { PipelineStep, PipelinePhase, StepConfig } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';

@StepDefinition({
  name: 'NoOpStep',
  phase: PipelinePhase.PROCESSING,
  injects: ['ContextSubsystem'],
})
export class NoOpStep implements PipelineStep {
  config: StepConfig = { onError: 'continue' };

  constructor(private readonly contextService: ContextSubsystem) {}

  async execute(requestId: string): Promise<void> {
    // No hace nada, solo simula un paso
    console.log(`[NoOpStep] requestId=${requestId} ‚îÄ NoOp ejecutado`);
  }
}
// src/pipeline/steps/normalizer.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

@StepDefinition({
  name: 'NormalizerStep',
  phase: PipelinePhase.PROCESSING,
  injects: ['ContextSubsystem'],
})
export class NormalizerStep extends BaseGenericStep {
  // Si hay error de tipado o similar, el pipeline contin√∫a (no es cr√≠tico)
  config = { onError: 'continue' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'NormalizerStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PROCESSING;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Tomamos el objeto a normalizar
    const source = context.meta.validatedBody ?? context.body;
    if (typeof source === 'object' && source !== null) {
      const normalized: any = {};
      for (const [key, value] of Object.entries(source)) {
        if (typeof value === 'string') {
          // trim y lowercase
          normalized[key] = value.trim().toLowerCase();
        } else {
          normalized[key] = value;
        }
      }
      context.meta.normalizedBody = normalized;
    } else {
      // No hay nada v√°lido que normalizar
      context.meta.normalizedBody = source;
    }

    // 2) Log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/notifier.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

interface NotificationEntry {
  message: string;
  time: number;
}

@StepDefinition({
  name: 'NotifierStep',
  phase: PipelinePhase.POST,
  injects: ['ContextSubsystem'],
})
export class NotifierStep extends BaseGenericStep {
  // Si falla la notificaci√≥n, continuamos (no es cr√≠tico)
  config = { onError: 'continue' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'NotifierStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.POST;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Simular env√≠o de notificaci√≥n (console.log)
    const msg = `Notificaci√≥n placeholder para requestId=${requestId}`;
    console.log(`[NotifierStep] ${msg}`);

    // 2) Push en context.meta.notifications
    if (!Array.isArray(context.meta.notifications)) {
      context.meta.notifications = [];
    }
    const notification: NotificationEntry = {
      message: msg,
      time: Date.now(),
    };
    context.meta.notifications.push(notification);

    // 3) Log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/rate-limiter.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

@StepDefinition({
  name: 'RateLimiterStep',
  phase: PipelinePhase.PRE,
  injects: ['ContextSubsystem'],
})
export class RateLimiterStep extends BaseGenericStep {
  // Detener el pipeline si supera el l√≠mite
  config = { onError: 'stop' as const };

  // Mapa est√°tico: key = identificador (IP o tenant), value = array de timestamps (ms)
  private static requestsMap: Map<string, number[]> = new Map();

  private readonly WINDOW_MS = 60_000; // 1 minuto
  private readonly MAX_REQUESTS = 10; // m√°ximo 10 requests por ventana

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'RateLimiterStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PRE;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Determinar ‚Äúidentificador‚Äù de rate-limiting: primero IP, luego tenant, sino "global"
    let key: string = 'global';
    if (context.headers['x-forwarded-for']) {
      // usar primera IP de x-forwarded-for
      key = String(context.headers['x-forwarded-for']).split(',')[0].trim();
    } else if (context.meta.tenant) {
      key = String(context.meta.tenant);
    }

    // 2) Obtener timestamps viejos y filtrar solo los de la ‚Äúventana‚Äù actual
    const now = Date.now();
    const windowStart = now - this.WINDOW_MS;
    const timestamps = RateLimiterStep.requestsMap.get(key) || [];
    const filtered = timestamps.filter((ts) => ts >= windowStart);

    // 3) Verificar si ya excede
    if (filtered.length >= this.MAX_REQUESTS) {
      throw new Error(`[RateLimiterStep] L√≠mite excedido para key="${key}" (m√°s de ${this.MAX_REQUESTS} req/min)`);
    }

    // 4) Agregar timestamp actual y guardar en el mapa
    filtered.push(now);
    RateLimiterStep.requestsMap.set(key, filtered);

    // 5) Continuar y registrar log
    await super.execute(requestId);
  }
}
// src/pipeline/steps/response-formatter-step.ts
import { PipelineStep, PipelinePhase, StepConfig } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';

@StepDefinition({
  name: 'ResponseFormatterStep',
  phase: PipelinePhase.POST,
  injects: ['ContextSubsystem'],
})
export class ResponseFormatterStep implements PipelineStep {
  name = 'ResponseFormatterStep';
  phase = PipelinePhase.POST;
  config = { onError: 'continue' as const };

  constructor(private readonly contextService: ContextSubsystem) {}

  async execute(requestId: string): Promise<void> {
    const ctx = this.contextService.getContext(requestId);
    if (!ctx) throw new Error('[ResponseFormatterStep] Contexto no encontrado');

    const duration = Date.now() - Number(ctx.requestId.replace('REQ-', ''));
    ctx.response = {
      success: true,
      requestId: ctx.requestId,
      timestamp: new Date().toISOString(),
      durationMs: duration,
      result: ctx.meta.validatedBody ?? {},
      logs: ctx.meta.logs,
    };
  }
}
// src/pipeline/steps/step-registry.ts

import { PipelineStepConstructor } from '../interfaces/pipeline-step.interface';

// Importa aqu√≠ todas las clases de Steps que quieres exponer en la f√°brica:
import { LoggingStep } from './logging-step';
import { NoOpStep } from './noop-step';
import { ResponseFormatterStep } from './response-formatter-step';

import { HeaderCheckStep } from './header-check.step';
import { RateLimiterStep } from './rate-limiter.step';
import { TokenParserStep } from './token-parser.step';
import { ValidationStep } from './validation.step';
import { NormalizerStep } from './normalizer.step';
import { ContextBuilderStep } from './context-builder.step';
import { BusinessAuditStep } from './business-audit.step';
import { MetadataTaggerStep } from './metadata-tagger.step';
import { NotifierStep } from './notifier.step';
import { TracerStep } from './tracer.step';

// Mapea cada name (igual al ‚Äúname‚Äù de @StepDefinition) a su clase:
export const STEP_REGISTRY: Record<string, PipelineStepConstructor> = {
  // Steps ‚Äúcore‚Äù que ya exist√≠an:
  'LoggingStep': LoggingStep,
  'NoOpStep': NoOpStep,
  'ResponseFormatterStep': ResponseFormatterStep,

  // Steps gen√©ricos Fase 3:
  'HeaderCheckStep': HeaderCheckStep,
  'RateLimiterStep': RateLimiterStep,
  'TokenParserStep': TokenParserStep,
  'ValidationStep': ValidationStep,
  'NormalizerStep': NormalizerStep,
  'ContextBuilderStep': ContextBuilderStep,
  'BusinessAuditStep': BusinessAuditStep,
  'MetadataTaggerStep': MetadataTaggerStep,
  'NotifierStep': NotifierStep,
  'TracerStep': TracerStep,

  // Si luego agregas pasos de Planes/ACL, incl√∫yelos aqu√≠:
  // 'PlanPermissionsStep': PlanPermissionsStep,
  // 'PlanAccessGuardStep': PlanAccessGuardStep,
};
// src/pipeline/steps/token-parser.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';
import * as jwt from 'jsonwebtoken';

@StepDefinition({
  name: 'TokenParserStep',
  phase: PipelinePhase.PRE,
  injects: ['ContextSubsystem'],
})
export class TokenParserStep extends BaseGenericStep {
  // Si falla la verificaci√≥n del token, detenemos el pipeline
  config = { onError: 'stop' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'TokenParserStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PRE;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Obtener header Authorization
    const authHeader = context.headers['authorization'] as string | undefined;
    if (!authHeader) {
      // No hay token: dejamos context.user como null y continuamos
      context.user = null;
      await super.execute(requestId);
      return;
    }

    // 2) Debe tener formato "Bearer <token>"
    const parts = authHeader.split(' ');
    if (parts.length !== 2 || parts[0].toLowerCase() !== 'bearer') {
      throw new Error('[TokenParserStep] Formato de Authorization inv√°lido. Debe ser "Bearer <token>".');
    }
    const token = parts[1];

    // 3) Intentar verificar si existe JWT_SECRET
    const secret = process.env.JWT_SECRET;
    if (secret) {
      try {
        const payload = jwt.verify(token, secret);
        context.user = payload;
        context.meta.tokenPayload = payload;
      } catch (err: any) {
        throw new Error(`[TokenParserStep] JWT inv√°lido o expirado: ${err.message}`);
      }
    } else {
      // Si no hay secreto, hacemos decode ‚Äúsin verificar‚Äù (ojo: no es seguro en prod)
      const payload = jwt.decode(token);
      context.user = payload as any;
      context.meta.tokenPayload = payload;
    }

    // 4) Registramos log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/tracer.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

interface TraceEntry {
  step: string;
  timestamp: number;
}

@StepDefinition({
  name: 'TracerStep',
  phase: PipelinePhase.POST,
  injects: ['ContextSubsystem'],
})
export class TracerStep extends BaseGenericStep {
  // Si falla, continuamos (no cr√≠tico)
  config = { onError: 'continue' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'TracerStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.POST;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) Inicializar array de trazas si no existe
    if (!Array.isArray(context.meta.traceSteps)) {
      context.meta.traceSteps = [];
    }

    // 2) Agregar un entry de trazo
    const entry: TraceEntry = {
      step: this.getName(),
      timestamp: Date.now(),
    };
    context.meta.traceSteps.push(entry);

    // 3) Tambi√©n imprimir un console.log
    console.log(`[TracerStep] Se a√±adi√≥ trazo:`, entry);

    // 4) Log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/steps/validation.step.ts
import { PipelinePhase } from '../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../subsystems/context/context.subsystem';
import { StepDefinition } from '../decorators/step-definition.decorator';
import { BaseGenericStep } from './base-step';

@StepDefinition({
  name: 'ValidationStep',
  phase: PipelinePhase.PROCESSING,
  injects: ['ContextSubsystem'],
})
export class ValidationStep extends BaseGenericStep {
  // Si falta body o no es objeto, detenemos el pipeline
  config = { onError: 'stop' as const };

  constructor(ctx: ContextSubsystem) {
    super(ctx);
  }

  getName(): string {
    return 'ValidationStep';
  }

  getPhase(): PipelinePhase {
    return PipelinePhase.PROCESSING;
  }

  public async execute(requestId: string): Promise<void> {
    const context = this.ctx.getContext(requestId)!;

    // 1) context.body debe existir y ser un objeto
    if (
      context.body === null ||
      context.body === undefined ||
      typeof context.body !== 'object' ||
      Array.isArray(context.body)
    ) {
      throw new Error('[ValidationStep] El cuerpo de la petici√≥n debe ser un objeto JSON.');
    }

    // 2) Debe tener por lo menos una propiedad
    if (Object.keys(context.body).length === 0) {
      throw new Error('[ValidationStep] El body no puede estar vac√≠o.');
    }

    // 3) OK: guardamos validatedBody
    context.meta.validatedBody = { ...context.body };

    // 4) Registrar log de √©xito
    await super.execute(requestId);
  }
}
// src/pipeline/subsystems/audit/audit-adapter.interface.ts
export interface AuditEntry {
  event: string;
  payload: any;
  timestamp: number;
}

export interface AuditAdapter {
  record(data: AuditEntry): Promise<void>;
}
// src/pipeline/subsystems/audit/audit-trail.subsystem.ts
import { Injectable } from '@nestjs/common';
import { ConsoleAuditAdapter } from './console.adapter';
import { AuditAdapter, AuditEntry } from './audit-adapter.interface';

@Injectable()
export class AuditTrailSubsystem {
  private adapters: AuditAdapter[] = [new ConsoleAuditAdapter()];

  async logEvent(event: string, payload: any) {
    const entry: AuditEntry = {
      event,
      payload,
      timestamp: Date.now(),
    };
    for (const adapter of this.adapters) {
      await adapter.record(entry);
    }
  }

  addAdapter(adapter: AuditAdapter) {
    this.adapters.push(adapter);
  }
}
// src/pipeline/subsystems/audit/console.adapter.ts

import { AuditAdapter, AuditEntry } from "./audit-adapter.interface";


export class ConsoleAuditAdapter implements AuditAdapter {
  async record(data: AuditEntry): Promise<void> {
    console.log(
      `[AUDIT] ${data.event}`,
      JSON.stringify(data.payload),
      `@ ${new Date(data.timestamp).toISOString()}`,
    );
  }
}
import { Injectable, Logger } from '@nestjs/common';
import * as fs from 'fs';
import * as path from 'path';
import { RequestContext } from '../../interfaces/context.interface';

@Injectable()
export class ConfigurationSubsystem {
  private globalConfig: any;
  private readonly logger = new Logger(ConfigurationSubsystem.name);

  constructor() {
    // ‚úÖ Carga config global al iniciar (default.json)
    this.globalConfig = this.loadConfigFile('default');
    this.logger.log(`[CONFIG] ‚úÖ Configuraci√≥n global cargada: ${JSON.stringify(this.globalConfig)}`);
  }

  /**
   * Carga un archivo de configuraci√≥n (e.g. default.json, tenant.json)
   */
  private loadConfigFile(name: string): any {
    // üìÅ Calcula path absoluto al directorio de configuraci√≥n
    const configDir = path.resolve(__dirname, '../../../../config');
    const configPath = path.join(configDir, `${name}.json`);

    this.logger.log(`[CONFIG] üîç Intentando cargar configuraci√≥n: ${configPath}`);

    if (fs.existsSync(configPath)) {
      try {
        const fileContent = fs.readFileSync(configPath, 'utf-8');
        const parsed = JSON.parse(fileContent);
        this.logger.log(`[CONFIG] ‚úÖ Archivo cargado correctamente: ${name}.json`);
        return parsed;
      } catch (err: any) {
        this.logger.error(`[CONFIG] ‚ùå Error al parsear el archivo: ${configPath}`, err.stack);
        return {};
      }
    } else {
      this.logger.warn(`[CONFIG] ‚ö†Ô∏è Archivo no encontrado: ${configPath}`);
      return {};
    }
  }

  /**
   * Devuelve la configuraci√≥n combinada (default + tenant)
   */
  public getConfig(context: RequestContext): any {
    if (!context.meta.__config) {
      const tenant = context.headers?.['x-tenant'] || 'default';
      const tenantConfig = this.loadConfigFile(tenant);
      const combined = {
        ...this.globalConfig,
        ...tenantConfig,
      };
      this.logger.log(`[CONFIG] üß© Configuraci√≥n combinada (${tenant}): ${JSON.stringify(combined)}`);
      context.meta.__config = combined;
    }
    return context.meta.__config;
  }

  /**
   * Devuelve un valor del config global
   */
  public getValue(key: string, fallback: any = null): any {
    return this.globalConfig[key] ?? fallback;
  }
}
// src/pipeline/subsystems/context/context.subsystem.ts
import { Injectable } from '@nestjs/common';
import { RequestContext } from '../../interfaces/context.interface';

@Injectable()
export class ContextSubsystem {
  private contextMap = new Map<string, RequestContext>();

  public setContext(context: RequestContext): void {
    this.contextMap.set(context.requestId, context);
  }

  public getContext(requestId: string): RequestContext | undefined {
    return this.contextMap.get(requestId);
  }

  public deleteContext(requestId: string): void {
    this.contextMap.delete(requestId);
  }
}
// src/pipeline/subsystems/error-manager/error-manager.subsystem.ts
import { Injectable } from '@nestjs/common';
import { RequestContext } from '../../interfaces/context.interface';

@Injectable()
export class ErrorManagerSubsystem {
  async handle(error: any, context: RequestContext, stepName: string) {
    context.errors ??= [];
    context.errors.push({
      step: stepName,
      message: error.message || 'Unknown error',
      timestamp: Date.now(),
    });
    console.error(`[ERROR][${stepName}]`, error);
  }
}
// src/pipeline/subsystems/execution-controller/execution-controller.subsystem.ts
import { Injectable } from '@nestjs/common';
import { PipelinePhase } from '../../interfaces/pipeline-step.interface';
import { RequestContext } from '../../interfaces/context.interface';
import { ConfigurationSubsystem } from '../configuration/configuration.subsystem';

@Injectable()
export class ExecutionControllerSubsystem {
  constructor(private readonly config: ConfigurationSubsystem) {}

  public isPhaseEnabled(
    phase: PipelinePhase,
    context: RequestContext,
  ): boolean {
    const cfg = this.config.getConfig(context);
    if (cfg.disabledPhases && Array.isArray(cfg.disabledPhases)) {
      return !cfg.disabledPhases.includes(phase);
    }
    return true;
  }

  public isStepEnabled(stepName: string, context: RequestContext): boolean {
    const cfg = this.config.getConfig(context);
    if (cfg.disabledSteps && Array.isArray(cfg.disabledSteps)) {
      return !cfg.disabledSteps.includes(stepName);
    }
    return true;
  }
}
// src/pipeline/subsystems/filter/step-filter.subsystem.ts
import { Injectable } from '@nestjs/common';
import { PipelinePhase, PipelineStep } from '../../interfaces/pipeline-step.interface';
import { ContextSubsystem } from '../context/context.subsystem';
import { ExecutionControllerSubsystem } from '../execution-controller/execution-controller.subsystem';

@Injectable()
export class StepFilterSubsystem {
  constructor(
    private readonly executionController: ExecutionControllerSubsystem,
    private readonly contextService: ContextSubsystem,
  ) {}

  public filter(
    phase: PipelinePhase,
    steps: PipelineStep[],
    requestId: string,
  ): PipelineStep[] {
    const context = this.contextService.getContext(requestId);
    if (!context) return [];

    if (!this.executionController.isPhaseEnabled(phase, context)) {
      return [];
    }

    return steps.filter((step) => {
      const stepName = step.constructor.name;
      return this.executionController.isStepEnabled(stepName, context);
    });
  }
}
// src/pipeline/subsystems/log/log-collector.subsystem.ts
import { Injectable } from '@nestjs/common';
import { RequestContext, StepExecutionLog } from '../../interfaces/context.interface';

@Injectable()
export class LogCollectorSubsystem {
  collect(context: RequestContext, log: StepExecutionLog) {
    if (!context.meta.logs) context.meta.logs = [];
    context.meta.logs.push(log);
    console.log(
      `[LOG] (${log.phase}) [${log.step}] ‚Üí ${log.status.toUpperCase()} (${log.durationMs}ms)`,
    );
  }
}
// src/core/pipeline/subsystems/service/service-resolver.subsystem.ts
import { Injectable } from '@nestjs/common';

/**
 * Este subsistema act√∫a como contenedor de servicios accesibles desde steps.
 * Permite registrar (registrar<T>(Clase, instancia)) servicios NestJS
 * y luego resolverlos con resolve<T>(Clase).
 */
@Injectable()
export class ServiceResolverSubsystem {
  private services = new Map<new (...args: any[]) => any, any>();

  /**
   * Registrar un servicio bajo su clase (token).
   * Ejemplo: resolver.register(PlansService, this.plansServiceInstance)
   */
  register<T>(token: new (...args: any[]) => T, instance: T): void {
    this.services.set(token, instance);
  }

  /**
   * Recuperar un servicio previamente registrado.
   * Ejemplo: const plans = resolver.resolve(PlansService)
   */
  resolve<T>(token: new (...args: any[]) => T): T | undefined {
    return this.services.get(token);
  }

  /**
   * Limpiar todos los servicios registrados (al terminar la petici√≥n).
   */
  clear(): void {
    this.services.clear();
  }
}
// apps/api-core/src/testing/controllers/demo.controller.ts
import { Controller, Post, Req, Res } from '@nestjs/common';
import { UsePipeline } from '../../pipeline/decorators/pipeline.decorator';
import { Request, Response } from 'express';

@Controller('testing')
export class DemoController {
  @UsePipeline('PipelineGen√©ricoDemo')
  @Post('demo-generico')
  async runDemo(
    @Req() request: Request, 
    @Res() response: Response
  ) {
    return response.json(request.pipelineContext.response);
  }
}
// src/testing/controllers/test-noop.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { UsePipeline } from '../../pipeline/decorators/pipeline.decorator';

@Controller('test/noop')
export class TestNoOpController {
  @Post()
  @UsePipeline('NoOpPipeline')
  testNoOp(@Body() body: any) {
    return {
      ok: true,
      mensaje: '‚úÖ Ejecutado con NoOpPipeline',
      received: body,
    };
  }
}
// src/testing/controllers/test-plan-access.controller.ts
import { Controller, Post, Body } from '@nestjs/common';
import { UsePipeline } from '../../pipeline/decorators/pipeline.decorator';

class TestPlanAccessDto {
  planId: string = 'basic';
  feature: string = 'featureA';
}

@Controller('test/plan-access')
@UsePipeline('TestPlanAccessPipeline')
export class TestPlanAccessController {
  @Post()
  test(@Body() body: TestPlanAccessDto) {
    // Si llegamos aqu√≠, significa que el pipeline permiti√≥ el acceso
    return { source: body };
  }
}
// src/testing/services/pipeline-test-runner.service.ts
import { Injectable, Inject } from '@nestjs/common';
import { RequestPipelineProvider } from '../../pipeline/request-pipeline.provider';
import { ContextSubsystem } from '../../pipeline/subsystems/context/context.subsystem';
import { ServiceResolverSubsystem } from '../../pipeline/subsystems/service/service-resolver.subsystem';
import { StepExecutionLog, RequestContext } from '../../pipeline/interfaces/context.interface';
import { PipelineEngineService } from '../../pipeline/pipeline-engine.service';

@Injectable()
export class PipelineTestRunnerService {
  constructor(
    private readonly engine: PipelineEngineService,
    private readonly contextService: ContextSubsystem,
    private readonly serviceResolver: ServiceResolverSubsystem,
    @Inject('PIPELINE_FACTORY') private readonly factory: any,
  ) {}

  async run(pipelineName: string, input: any) {
    const requestId = `TEST-${Date.now()}`;
    // Construir contexto manual
    const context: RequestContext = {
      requestId,
      body: input,
      headers: {},
      user: { id: 'u1', email: 'a@b.com', plan: 'basic', permissions: [] },
      meta: { logs: [] },
      services: {},
    };
    // Si necesitan un servicio, lo registran manualmente:
    // this.serviceResolver.register(PlansService, <instanciaPlansService>);
    context.services = {
      // p. ej. PlansService: instancia,
    };

    // Obtener pipeline
    const steps = await this.factory.getPipeline(pipelineName);
    // Ejecutar
    await this.engine.executeWithSteps(context, steps);

    return {
      response: context.response,
      logs: context.meta.logs as StepExecutionLog[],
      errors: context.errors,
    };
  }
}
// src/testing/testing.module.ts
import { Module } from '@nestjs/common';

import { TestNoOpController } from './controllers/test-noop.controller';
import { TestPlanAccessController } from './controllers/test-plan-access.controller';
import { DemoController } from './controllers/demo.controller';
import { PipelineTestRunnerService } from './services/pipeline-test-runner.service';
import { RuntimePipelineModule } from '../pipeline/runtime-pipeline.module';
import { PipelineFactoryModule } from '../pipeline/factory/pipeline-factory.module';

@Module({
  imports: [
    // IMPORTAMOS los dos m√≥dulos de pipeline para que TestingModule pueda resolver:
    RuntimePipelineModule,
    PipelineFactoryModule,
  ],
  controllers: [
    TestNoOpController,
    TestPlanAccessController,
    DemoController,
  ],
  providers: [
    PipelineTestRunnerService,
  ],
  exports: [
    PipelineTestRunnerService,
  ],
})
export class TestingModule {}
// src/types/express.d.ts
import { RequestContext } from '../pipeline/interfaces/context.interface';

declare module 'express' {
  export interface Request {
    pipelineContext: RequestContext;
  }
}
